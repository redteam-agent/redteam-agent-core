"""
Exploit chain engine for generating and executing exploit chains.

The exploit chain is the core of the red teaming process:
1. Takes vulnerability scan results and knowledge base as input
2. Uses the LLM to generate step-by-step exploit attempts
3. Executes each step via the executor service
4. Evaluates results and adapts the chain
5. Continues until success or max steps reached
"""

import json
import re
from typing import AsyncIterator

import structlog
from pydantic import BaseModel

from ..events import EventEmitter
from ..executor import ExecutorClient, ExecutorError, ExecutorType, TargetInfo
from ..llm import LLMResponse, OpenRouterProvider
from ..models.app_context import AppContext
from ..models.events import CommandStatus, PipelineStage
from ..models.results import ChainStep, ChainType, ExploitResult, StepStatus
from ..models.vulnerability import SecurityIssue, VulnerabilityInfo, VulnerabilityKnowledgeBase

logger = structlog.get_logger(__name__)


class ExploitPlan(BaseModel):
    """Initial plan for an exploit attempt."""

    vulnerability: SecurityIssue
    attack_vectors: list[str]
    initial_approach: str
    relevant_knowledge: list[VulnerabilityInfo]


class StepResult(BaseModel):
    """Result of executing a single step."""

    success: bool
    output: str
    exit_code: int
    error: str | None = None
    is_exploited: bool = False
    evidence: str | None = None


# System prompt for exploit chain generation
EXPLOIT_SYSTEM_PROMPT = """You are a security researcher conducting authorized penetration testing.
You are testing a web application for vulnerabilities as part of a security assessment.

Your task is to generate exploit steps to verify vulnerabilities found by automated scanners.
Think carefully about each step and explain your reasoning in <think> tags.

Important:
- Only attempt exploits that could realistically work based on the vulnerability type
- Be methodical and try different variations if initial attempts fail
- Document evidence of successful exploitation
- Do not cause permanent damage to the system
- Focus on proving the vulnerability exists, not maximum impact

Output your response as JSON with this structure:
{
    "reasoning": "Your step-by-step thinking about what to try",
    "command": "The exact command to execute (curl, HTTP request, etc.)",
    "expected_outcome": "What you expect to see if this works",
    "success_criteria": "How to determine if exploitation was successful",
    "fallback_strategy": "What to try if this doesn't work"
}"""


class ExploitChain:
    """
    Exploit chain engine for verifying vulnerabilities.

    Uses the LLM to generate exploit attempts and the executor
    service to run them against the target application.
    """

    def __init__(
        self,
        llm: OpenRouterProvider,
        emitter: EventEmitter,
        max_steps: int = 30,
    ):
        """
        Initialize the exploit chain.

        Args:
            llm: LLM provider for generating exploit steps
            emitter: Event emitter for streaming updates
            max_steps: Maximum number of steps to attempt
        """
        self.llm = llm
        self.emitter = emitter
        self.max_steps = max_steps
        self.result: ExploitResult | None = None

    async def plan_exploit(
        self,
        app_context: AppContext,
        vulnerability: SecurityIssue,
        knowledge_base: VulnerabilityKnowledgeBase,
    ) -> ExploitPlan:
        """
        Create an initial exploit plan.

        Args:
            app_context: Application context
            vulnerability: Vulnerability to exploit
            knowledge_base: Knowledge base of known exploits

        Returns:
            ExploitPlan with initial approach
        """
        # Find relevant knowledge
        relevant = []
        if vulnerability.cwe_id:
            relevant.extend(knowledge_base.search_by_cwe(vulnerability.cwe_id))

        relevant.extend(
            knowledge_base.search_by_category(vulnerability.category)[:5]
        )

        # Determine attack vectors based on vulnerability type
        attack_vectors = self._get_attack_vectors(vulnerability)

        return ExploitPlan(
            vulnerability=vulnerability,
            attack_vectors=attack_vectors,
            initial_approach=attack_vectors[0] if attack_vectors else "Generic exploit",
            relevant_knowledge=relevant[:3],  # Limit to 3 most relevant
        )

    def _get_attack_vectors(self, vulnerability: SecurityIssue) -> list[str]:
        """Determine possible attack vectors for a vulnerability type."""
        category = vulnerability.category.lower()

        vectors = {
            "sql_injection": [
                "UNION-based injection",
                "Boolean-based blind injection",
                "Time-based blind injection",
                "Error-based injection",
            ],
            "xss": [
                "Reflected XSS via URL parameter",
                "Stored XSS via form input",
                "DOM-based XSS",
            ],
            "ssrf": [
                "Internal service access",
                "Cloud metadata access",
                "File protocol access",
            ],
            "idor": [
                "Direct object reference manipulation",
                "Sequential ID enumeration",
                "GUID manipulation",
            ],
            "authentication": [
                "Credential stuffing",
                "Session fixation",
                "JWT manipulation",
            ],
            "command_injection": [
                "Shell command injection",
                "OS command injection via semicolon",
                "Command substitution",
            ],
        }

        return vectors.get(category, ["Generic vulnerability exploitation"])

    async def execute_step(
        self,
        step: ChainStep,
        executor: ExecutorClient,
        target: TargetInfo,
        session_id: str,
        run_id: str,
    ) -> StepResult:
        """
        Execute a single exploit step.

        Args:
            step: The step to execute
            executor: Executor client for running commands
            target: Target application info
            session_id: Current session ID
            run_id: Current run ID

        Returns:
            StepResult with execution outcome
        """
        try:
            # Determine executor type from command
            executor_type = self._determine_executor_type(step.command)

            result = await executor.execute(
                session_id=session_id,
                run_id=run_id,
                command=step.command,
                executor_type=executor_type,
                target=target,
                timeout=30,
            )

            return StepResult(
                success=result.exit_code == 0,
                output=result.stdout or result.stderr,
                exit_code=result.exit_code,
            )

        except ExecutorError as e:
            return StepResult(
                success=False,
                output="",
                exit_code=-1,
                error=str(e),
            )

    def _determine_executor_type(self, command: str) -> ExecutorType:
        """Determine the executor type based on command."""
        command_lower = command.lower()
        if command_lower.startswith("curl") or command_lower.startswith("http"):
            return ExecutorType.HTTP
        elif "gcloud" in command_lower:
            return ExecutorType.CLOUDRUN
        else:
            return ExecutorType.SHELL

    async def run_chain(
        self,
        app_context: AppContext,
        vulnerability: SecurityIssue,
        knowledge_base: VulnerabilityKnowledgeBase,
        executor: ExecutorClient,
    ) -> AsyncIterator[ChainStep]:
        """
        Run the complete exploit chain.

        Args:
            app_context: Application context
            vulnerability: Vulnerability to exploit
            knowledge_base: Knowledge base of exploits
            executor: Executor client

        Yields:
            ChainStep objects as steps are executed
        """
        # Create initial plan
        plan = await self.plan_exploit(app_context, vulnerability, knowledge_base)

        # Build target info
        target = TargetInfo(
            url=app_context.app_url,
            gcp_project_id=app_context.gcp_project_id,
            gcp_region=app_context.gcp_region,
            gcp_service_name=app_context.gcp_service_name,
        )

        steps_executed: list[ChainStep] = []
        previous_results: list[str] = []
        exploit_successful = False
        evidence = None

        for step_number in range(1, self.max_steps + 1):
            # Generate next step
            step = await self._generate_step(
                app_context=app_context,
                plan=plan,
                step_number=step_number,
                previous_steps=steps_executed,
                previous_results=previous_results,
            )

            if step is None:
                logger.info("no_more_steps", vulnerability_id=vulnerability.id)
                break

            # Emit reasoning event
            if step.reasoning:
                await self.emitter.emit_reasoning(
                    step_number=step_number,
                    chain_type=ChainType.EXPLOIT,
                    reasoning_text=step.reasoning,
                )

            # Emit command event (running)
            await self.emitter.emit_command(
                step_number=step_number,
                command=step.command,
                status=CommandStatus.RUNNING,
                executor_type=self._determine_executor_type(step.command).value,
            )

            # Execute step
            result = await self.execute_step(
                step=step,
                executor=executor,
                target=target,
                session_id=app_context.session_id,
                run_id=app_context.run_id or "",
            )

            # Update step with result
            step.output = result.output
            step.exit_code = result.exit_code
            step.status = StepStatus.SUCCESS if result.success else StepStatus.FAILED

            # Emit output event
            await self.emitter.emit_output(
                step_number=step_number,
                output=result.output,
                stream="stdout" if result.success else "stderr",
            )

            # Emit command event (completed)
            await self.emitter.emit_command(
                step_number=step_number,
                command=step.command,
                status=CommandStatus.SUCCESS if result.success else CommandStatus.FAILED,
                executor_type=self._determine_executor_type(step.command).value,
            )

            steps_executed.append(step)
            previous_results.append(f"Step {step_number}: {result.output[:500]}")

            yield step

            # Check if exploit was successful
            if await self._check_exploitation_success(
                step, result, vulnerability, app_context
            ):
                exploit_successful = True
                evidence = self._extract_evidence(result, vulnerability)
                break

        # Build final result
        self.result = ExploitResult(
            success=exploit_successful,
            vulnerability_id=vulnerability.id,
            vulnerability_type=vulnerability.category,
            severity=vulnerability.severity.value,
            steps_executed=steps_executed,
            total_steps=len(steps_executed),
            evidence=evidence,
            impact=self._determine_impact(vulnerability, exploit_successful),
            summary=self._generate_summary(vulnerability, exploit_successful, steps_executed),
        )

        # Emit exploit result event
        await self.emitter.emit_exploit_result(
            success=exploit_successful,
            vulnerability_id=vulnerability.id,
            vulnerability_type=vulnerability.category,
            severity=vulnerability.severity.value,
            summary=self.result.summary,
            evidence=evidence,
        )

    async def _generate_step(
        self,
        app_context: AppContext,
        plan: ExploitPlan,
        step_number: int,
        previous_steps: list[ChainStep],
        previous_results: list[str],
    ) -> ChainStep | None:
        """Generate the next exploit step using the LLM."""
        # Build prompt
        prompt = self._build_step_prompt(
            app_context=app_context,
            plan=plan,
            step_number=step_number,
            previous_steps=previous_steps,
            previous_results=previous_results,
        )

        try:
            response = await self.llm.generate_json(
                prompt=prompt,
                system=EXPLOIT_SYSTEM_PROMPT,
                temperature=0.7,
            )

            # Parse response
            step_data = self._parse_step_response(response)
            if step_data is None:
                return None

            return ChainStep(
                step_number=step_number,
                chain_type=ChainType.EXPLOIT,
                reasoning=step_data.get("reasoning", ""),
                command=step_data.get("command", ""),
                expected_outcome=step_data.get("expected_outcome", ""),
                success_criteria=step_data.get("success_criteria", ""),
                fallback_strategy=step_data.get("fallback_strategy"),
                status=StepStatus.PENDING,
            )

        except Exception as e:
            logger.error("step_generation_failed", error=str(e))
            return None

    def _build_step_prompt(
        self,
        app_context: AppContext,
        plan: ExploitPlan,
        step_number: int,
        previous_steps: list[ChainStep],
        previous_results: list[str],
    ) -> str:
        """Build the prompt for generating the next step."""
        context = f"""
APPLICATION CONTEXT:
{app_context.to_llm_context()}

VULNERABILITY BEING TESTED:
- ID: {plan.vulnerability.id}
- Type: {plan.vulnerability.category}
- Severity: {plan.vulnerability.severity.value}
- Title: {plan.vulnerability.title}
- Description: {plan.vulnerability.description}
{f'- File: {plan.vulnerability.file_path}:{plan.vulnerability.line_number}' if plan.vulnerability.file_path else ''}
{f'- CWE: {plan.vulnerability.cwe_id}' if plan.vulnerability.cwe_id else ''}

ATTACK VECTORS TO CONSIDER:
{chr(10).join(f'- {v}' for v in plan.attack_vectors)}

RELEVANT KNOWLEDGE FROM EXPLOIT DATABASE:
"""
        for kb in plan.relevant_knowledge:
            context += f"""
- {kb.title}
  Techniques: {', '.join(kb.exploitation_techniques[:3]) if kb.exploitation_techniques else 'N/A'}
  PoC: {kb.proof_of_concepts[0][:200] if kb.proof_of_concepts else 'N/A'}
"""

        if previous_steps:
            context += "\n\nPREVIOUS STEPS AND RESULTS:\n"
            for step, result in zip(previous_steps, previous_results):
                context += f"""
Step {step.step_number}: {step.command}
Result: {result[:500]}
"""

        context += f"""

CURRENT STEP: {step_number} of {self.max_steps}

Based on the above, generate the next exploit step.
If you believe the exploit is complete or no further steps are needed, respond with:
{{"done": true, "reason": "explanation"}}

Otherwise, provide the next step in JSON format.
"""
        return context

    def _parse_step_response(self, response: LLMResponse) -> dict | None:
        """Parse the LLM response into step data."""
        try:
            # Try to parse as JSON
            content = response.content.strip()

            # Handle code blocks
            if "```json" in content:
                content = content.split("```json")[1].split("```")[0]
            elif "```" in content:
                content = content.split("```")[1].split("```")[0]

            data = json.loads(content)

            # Check if chain is done
            if data.get("done", False):
                return None

            # Validate required fields
            if not data.get("command"):
                return None

            return data

        except json.JSONDecodeError:
            logger.warning("json_parse_failed", content=response.content[:200])
            return None

    async def _check_exploitation_success(
        self,
        step: ChainStep,
        result: StepResult,
        vulnerability: SecurityIssue,
        app_context: AppContext,
    ) -> bool:
        """Check if the exploit was successful based on the result."""
        output_lower = result.output.lower()
        category = vulnerability.category.lower()

        # Check for common success indicators based on vulnerability type
        if category == "sql_injection":
            indicators = ["sql syntax", "mysql", "postgresql", "database error", "union select"]
            return any(ind in output_lower for ind in indicators)

        elif category == "xss":
            indicators = ["<script>", "javascript:", "onerror", "onload"]
            return any(ind in output_lower for ind in indicators)

        elif category == "ssrf":
            indicators = ["169.254", "metadata", "internal", "localhost", "127.0.0.1"]
            return any(ind in output_lower for ind in indicators)

        elif category == "idor":
            # Check if we got data we shouldn't have access to
            return result.success and len(result.output) > 100

        elif category == "authentication":
            indicators = ["token", "session", "authenticated", "logged in", "access granted"]
            return any(ind in output_lower for ind in indicators)

        # Default: consider success if command succeeded and got substantial output
        return result.success and len(result.output) > 50

    def _extract_evidence(
        self,
        result: StepResult,
        vulnerability: SecurityIssue,
    ) -> str:
        """Extract evidence of successful exploitation."""
        output = result.output[:1000]  # Limit evidence length
        return f"Exploitation Evidence:\n{output}"

    def _determine_impact(
        self,
        vulnerability: SecurityIssue,
        exploit_successful: bool,
    ) -> str:
        """Determine the impact of a successful exploit."""
        if not exploit_successful:
            return "Unable to exploit vulnerability"

        category = vulnerability.category.lower()
        impacts = {
            "sql_injection": "Database access - potential data extraction or manipulation",
            "xss": "Client-side code execution - potential session hijacking",
            "ssrf": "Internal network access - potential data exfiltration",
            "idor": "Unauthorized data access - privacy violation",
            "authentication": "Authentication bypass - unauthorized access",
            "command_injection": "Server-side code execution - full system compromise",
        }
        return impacts.get(category, "Security vulnerability confirmed")

    def _generate_summary(
        self,
        vulnerability: SecurityIssue,
        exploit_successful: bool,
        steps_executed: list[ChainStep],
    ) -> str:
        """Generate a human-readable summary of the exploit attempt."""
        status = "Successfully exploited" if exploit_successful else "Failed to exploit"
        return (
            f"{status} {vulnerability.category} vulnerability ({vulnerability.severity.value}). "
            f"Attempted {len(steps_executed)} steps. "
            f"Vulnerability: {vulnerability.title}"
        )
